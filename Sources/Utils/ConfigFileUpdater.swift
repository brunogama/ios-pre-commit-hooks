import Foundation
import Rainbow

/// Protocol for file existence checker
protocol FileSystemChecker {
    func fileExists(atPath path: String) -> Bool
}

/// Default file existence checker implementation
final class DefaultFileSystemChecker: FileSystemChecker {
    private let fileManager: FileManager
    
    init(fileManager: FileManager = .default) {
        self.fileManager = fileManager
    }
    
    func fileExists(atPath path: String) -> Bool {
        return fileManager.fileExists(atPath: path)
    }
}

/// Protocol for config file content reader
protocol ConfigContentReader {
    func readConfig(fromPath path: String) throws -> String
}

/// Default config file reader implementation
final class DefaultConfigContentReader: ConfigContentReader {
    func readConfig(fromPath path: String) throws -> String {
        return try String(contentsOfFile: path, encoding: .utf8)
    }
}

/// Protocol for config file content writer
protocol ConfigContentWriter {
    func writeConfig(_ content: String, toPath path: String) throws
}

/// Default config file writer implementation
final class DefaultConfigContentWriter: ConfigContentWriter {
    func writeConfig(_ content: String, toPath path: String) throws {
        try content.write(toFile: path, atomically: true, encoding: .utf8)
    }
}

/// Protocol for marker checker in config files
protocol MarkerChecker {
    func containsMarker(_ content: String, marker: String) -> Bool
}

/// Default marker checker implementation
final class DefaultMarkerChecker: MarkerChecker {
    func containsMarker(_ content: String, marker: String) -> Bool {
        return content.contains(marker)
    }
}

/// Protocol for config template handler
protocol ConfigTemplateHandler {
    func handleTemplate(content: String, fromPath path: String) -> String?
}

/// Default config template handler implementation
final class DefaultConfigTemplateHandler: ConfigTemplateHandler {
    func handleTemplate(content: String, fromPath path: String) -> String? {
        let trimmedContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmedContent.isEmpty ? nil : trimmedContent
    }
}

/// Logger protocol for operation logging
protocol ConfigOperationLogger {
    func log(message: String)
    func logWarning(message: String)
    func logSuccess(message: String)
}

/// Default operation logger implementation
final class DefaultConfigOperationLogger: ConfigOperationLogger {
    private let verbose: Bool
    
    init(verbose: Bool = false) {
        self.verbose = verbose
    }
    
    func log(message: String) {
        if verbose {
            print(message)
        }
    }
    
    func logWarning(message: String) {
        if verbose {
            print(message.yellow)
        }
    }
    
    func logSuccess(message: String) {
        if verbose {
            print(message.green)
        }
    }
}

/// Config file updater that handles template integration with config files
final class ConfigFileUpdater {
    private let fileExistenceChecker: FileSystemChecker
    private let configReader: ConfigContentReader
    private let configWriter: ConfigContentWriter
    private let markerChecker: MarkerChecker
    private let templateHandler: ConfigTemplateHandler
    private let logger: ConfigOperationLogger
    
    init(fileExistenceChecker: FileSystemChecker = DefaultFileSystemChecker(),
         configReader: ConfigContentReader = DefaultConfigContentReader(),
         configWriter: ConfigContentWriter = DefaultConfigContentWriter(),
         markerChecker: MarkerChecker = DefaultMarkerChecker(),
         templateHandler: ConfigTemplateHandler = DefaultConfigTemplateHandler(),
         logger: ConfigOperationLogger) {
        self.fileExistenceChecker = fileExistenceChecker
        self.configReader = configReader
        self.configWriter = configWriter
        self.markerChecker = markerChecker
        self.templateHandler = templateHandler
        self.logger = logger
    }
    
    // Update config file with selected hook templates
    func updateConfigFileWithTemplates(selectedTemplates: [String], configPath: String) throws {
        // Create config file if it doesn't exist
        if !fileExistenceChecker.fileExists(atPath: configPath) {
            let defaultConfig = """
            # Default pre-commit config generated by pre-commit installer
            repos:
            """
            try configWriter.writeConfig(defaultConfig, toPath: configPath)
        }
        
        var configContent = try configReader.readConfig(fromPath: configPath)
        
        // Add marker for managed section if it doesn't exist
        let marker = "# Managed by pre-commit installer"
        if !markerChecker.containsMarker(configContent, marker: marker) {
            configContent += "\n\n\(marker)\n"
        }
        
        // For each selected template, extract its configuration
        for templateDir in selectedTemplates {
            let hooksTemplatesPath = "hooks-templates" as NSString
            let templateDirPath = hooksTemplatesPath.appendingPathComponent(templateDir)
            let templatePath = (templateDirPath as NSString).appendingPathComponent("template.yaml")
            
            if fileExistenceChecker.fileExists(atPath: templatePath) {
                if let templateContent = try? configReader.readConfig(fromPath: templatePath) {
                    // Process the template content
                    if let processedContent = templateHandler.handleTemplate(content: templateContent, fromPath: templatePath) {
                        // Add newlines for proper separation
                        configContent += "\n\n"
                        configContent += processedContent
                    }
                }
            } else {
                logger.logWarning(message: "⚠️ Template file not found: \(templatePath)")
            }
        }
        
        try configWriter.writeConfig(configContent, toPath: configPath)
        
        logger.logSuccess(message: "✓ Updated config file with selected templates")
    }
}

// Factory for creating ConfigFileUpdater with appropriate dependencies
final class ConfigFileUpdaterFactory {
    static func createUpdater(verbose: Bool) -> ConfigFileUpdater {
        let logger = DefaultConfigOperationLogger(verbose: verbose)
        return ConfigFileUpdater(logger: logger)
    }
}
