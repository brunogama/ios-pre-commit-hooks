import Foundation
import Rainbow

// Service handling actual installation of hooks and scripts
class InstallerService {
    private let fileManager = FileManager.default
    private let tempDir: String
    private var verbose: Bool
    
    // Current state tracking
    var selectedHooks: Set<String> = []
    var selectedScripts: Set<String> = []
    var availableTemplates: [(String, String)] = []
    var hookTemplates: [HookTemplate] = []
    
    init(verbose: Bool = false) throws {
        self.verbose = verbose
        // Create a unique temporary directory for the installation process
        tempDir = (NSTemporaryDirectory() as NSString).appendingPathComponent(UUID().uuidString)
        try fileManager.createDirectory(atPath: tempDir, withIntermediateDirectories: true, attributes: nil)
        
        if verbose {
            print("ℹ️ Temporary directory created at \(tempDir)".blue)
        }
    }
    
    deinit {
        // Clean up temporary directory
        try? fileManager.removeItem(atPath: tempDir)
        if verbose {
            print("ℹ️ Temporary directory removed".blue)
        }
    }
    
    // MARK: - Verification and Setup
    
    // Verify all necessary dependencies are available
    func verifyDependencies() throws {
        let requiredCommands = ["git", "pre-commit", "tar", "curl"]
        var missingDeps: [String] = []
        
        if verbose {
            print("Verifying dependencies...".yellow)
        }
        
        for cmd in requiredCommands {
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/which")
            process.arguments = [cmd]
            
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            
            do {
                try process.run()
                process.waitUntilExit()
                if process.terminationStatus != 0 {
                    missingDeps.append(cmd)
                }
            } catch {
                missingDeps.append(cmd)
            }
        }
        
        if !missingDeps.isEmpty {
            throw InstallerError.missingDependencies(missingDeps)
        }
        
        if verbose {
            print("✓ All dependencies are available".green)
        }
    }
    
    // Download the repository containing hook templates
    func downloadRepository(progressHandler: ((Double, String) -> Void)? = nil) throws {
        let archiveURL = Config.archiveURL
        let destinationURL = URL(fileURLWithPath: tempDir).appendingPathComponent("repo.tar.gz")
        
        // Helper function to update progress
        func updateProgress(_ progress: Double, _ message: String) {
            progressHandler?(progress, message)
        }
        
        updateProgress(0.1, "Starting download...")
        
        // Download using URLSession
        let semaphore = DispatchSemaphore(value: 0)
        var downloadError: Error?
        
        let task = URLSession.shared.downloadTask(with: URL(string: archiveURL)!) { tempURL, response, error in
            if let error = error {
                downloadError = error
                semaphore.signal()
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, 
                  (200...299).contains(httpResponse.statusCode) else {
                downloadError = InstallerError.downloadFailed("HTTP error")
                semaphore.signal()
                return
            }
            
            guard let tempURL = tempURL else {
                downloadError = InstallerError.downloadFailed("No download URL")
                semaphore.signal()
                return
            }
            
            do {
                try self.fileManager.moveItem(at: tempURL, to: destinationURL)
                updateProgress(0.5, "Download complete, extracting...")
                semaphore.signal()
            } catch {
                downloadError = error
                semaphore.signal()
            }
        }
        
        task.resume()
        semaphore.wait()
        
        if let downloadError = downloadError {
            throw InstallerError.downloadFailed(downloadError.localizedDescription)
        }
        
        // Extract tar.gz
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/tar")
        process.arguments = ["xzf", destinationURL.path, "-C", tempDir, "--strip-components=1"]
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            if process.terminationStatus != 0 {
                let errorData = pipe.fileHandleForReading.readDataToEndOfFile()
                let errorString = String(data: errorData, encoding: .utf8) ?? "Unknown error"
                throw InstallerError.extractionFailed(errorString)
            }
        } catch {
            throw InstallerError.extractionFailed(error.localizedDescription)
        }
        
        updateProgress(1.0, "Repository setup complete")
    }
    
    // MARK: - Hook and Script Management
    
    // Get available script templates
    func getAvailableTemplates() throws -> [(String, String)] {
        let scriptsDir = (tempDir as NSString).appendingPathComponent(Config.scriptsDir)
        
        guard fileManager.fileExists(atPath: scriptsDir) else {
            return []
        }
        
        let contents = try fileManager.contentsOfDirectory(atPath: scriptsDir)
        let templates = contents.filter { $0.hasSuffix(".sh") }.map { filename in
            (filename, getScriptDescription(filename: filename, inDirectory: scriptsDir))
        }
        
        self.availableTemplates = templates
        return templates
    }
    
    // Get hook templates from hooks-templates directory
    func getHookTemplates() throws -> [HookTemplate] {
        let templatesDir = "hooks-templates" // Path relative to the current directory
        
        guard fileManager.fileExists(atPath: templatesDir) else {
            if verbose {
                print("Hook templates directory not found: \(templatesDir)".yellow)
            }
            return []
        }
        
        // Get list of template directories
        let templateDirs = try fileManager.contentsOfDirectory(atPath: templatesDir)
        var templates: [HookTemplate] = []
        
        for dir in templateDirs {
            let dirPath = (templatesDir as NSString).appendingPathComponent(dir)
            
            // Skip non-directories
            var isDir: ObjCBool = false
            if !fileManager.fileExists(atPath: dirPath, isDirectory: &isDir) || !isDir.boolValue {
                continue
            }
            
            // Read README.md for description
            let readmePath = (dirPath as NSString).appendingPathComponent("README.md")
            var description = "No description available"
            if fileManager.fileExists(atPath: readmePath) {
                if let readmeContent = try? String(contentsOfFile: readmePath, encoding: .utf8) {
                    description = extractSummaryFromReadme(readmeContent)
                }
            }
            
            // Read template.yaml for configuration
            let templatePath = (dirPath as NSString).appendingPathComponent("template.yaml")
            var configContent = "No configuration available"
            if fileManager.fileExists(atPath: templatePath) {
                if let templateContent = try? String(contentsOfFile: templatePath, encoding: .utf8) {
                    configContent = templateContent
                }
            }
            
            // Create template object
            let template = HookTemplate(
                name: formatTemplateName(dir),
                directory: dir,
                description: description,
                configuration: configContent,
                isSelected: selectedHooks.contains(dir)
            )
            
            templates.append(template)
        }
        
        // Sort templates by name
        templates.sort { $0.name < $1.name }
        
        // Store templates
        self.hookTemplates = templates
        return templates
    }
    
    // Helper to format template name from directory name
    private func formatTemplateName(_ dirName: String) -> String {
        // Convert kebab-case to title case (e.g. "accessibility-check" -> "Accessibility Check")
        return dirName.split(separator: "-")
            .map { $0.prefix(1).uppercased() + $0.dropFirst().lowercased() }
            .joined(separator: " ")
    }
    
    // Helper to extract a brief summary from README.md content
    private func extractSummaryFromReadme(_ content: String) -> String {
        let lines = content.components(separatedBy: .newlines)
        
        // Find the first paragraph after skipping the title
        var seenTitle = false
        var paragraphLines: [String] = []
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip empty lines
            if trimmedLine.isEmpty {
                continue
            }
            
            // Handle Markdown title lines
            if trimmedLine.hasPrefix("#") {
                seenTitle = true
                continue
            }
            
            // If we've seen the title, collect the paragraph lines
            if seenTitle && !trimmedLine.isEmpty {
                paragraphLines.append(trimmedLine)
                
                // If we hit another empty line, we've got our paragraph
                if paragraphLines.count >= 4 {
                    break
                }
            }
        }
        
        // Return the first paragraph, or a default if none found
        if !paragraphLines.isEmpty {
            return paragraphLines.joined(separator: " ")
        }
        
        // Fallback: return the first non-empty, non-title line
        return lines.first { 
            let trimmed = $0.trimmingCharacters(in: .whitespacesAndNewlines)
            return !trimmed.isEmpty && !trimmed.hasPrefix("#")
        } ?? "No description available"
    }
    
    // Helper to get description of a script template
    private func getScriptDescription(filename: String, inDirectory: String) -> String {
        let path = (inDirectory as NSString).appendingPathComponent(filename)
        guard let contents = try? String(contentsOfFile: path, encoding: .utf8) else {
            return "No description available"
        }
        
        // Try to extract description from script's comment
        let lines = contents.components(separatedBy: .newlines)
        if let descLine = lines.first(where: { 
            let trimmed = $0.trimmingCharacters(in: .whitespaces)
            return trimmed.hasPrefix("#") && !trimmed.hasPrefix("#!")
        }) {
            return descLine.trimmingCharacters(in: CharacterSet(charactersIn: "# "))
        }
        
        return "No description found"
    }
    
    // MARK: - Installation
    
    // Setup selected scripts
    func setupScripts(_ scripts: [String]) throws {
        let sourceDir = (tempDir as NSString).appendingPathComponent(Config.scriptsDir)
        let destDir = Config.scriptsDir
        
        // Create scripts directory if it doesn't exist
        if !fileManager.fileExists(atPath: destDir) {
            try fileManager.createDirectory(atPath: destDir, withIntermediateDirectories: true, attributes: nil)
        }
        
        for script in scripts {
            let sourcePath = (sourceDir as NSString).appendingPathComponent(script)
            let destPath = (destDir as NSString).appendingPathComponent(script)
            
            if fileManager.fileExists(atPath: destPath) {
                try fileManager.removeItem(atPath: destPath)
            }
            
            try fileManager.copyItem(atPath: sourcePath, toPath: destPath)
            
            // Make script executable
            try fileManager.setAttributes([.posixPermissions: 0o755], ofItemAtPath: destPath)
            
            if verbose {
                print("✓ Installed script: \(script)".green)
            }
        }
    }
    
    // Update config file with selected hooks
    func updateConfigFile(hookIds: Set<String>, availableHooks: [HookGroup]) throws {
        let configPath = Config.configFile
        
        // Create config file if it doesn't exist
        if !fileManager.fileExists(atPath: configPath) {
            let defaultConfig = """
            # Default pre-commit config generated by pre-commit installer
            repos:
            """
            try defaultConfig.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        var configContent = try String(contentsOfFile: configPath, encoding: .utf8)
        
        // Group selected hooks by repo
        var hooksByRepo: [String: [(id: String, rev: String)]] = [:]
        var localHooks: [(id: String, name: String, entry: String, language: String)] = []
        
        for hookId in hookIds {
            let allHooks = availableHooks.flatMap { $0.hooks }
            if let hook = allHooks.first(where: { $0.id == hookId }) {
                if hook.repo == "local" {
                    localHooks.append((
                        id: hook.id,
                        name: hook.description,
                        entry: "\(Config.scriptsDir)/\(hook.id).sh",
                        language: "script"
                    ))
                } else {
                    if hooksByRepo[hook.repo] == nil {
                        hooksByRepo[hook.repo] = []
                    }
                    hooksByRepo[hook.repo]!.append((id: hook.id, rev: hook.rev))
                }
            }
        }
        
        // Add marker for managed section
        let marker = "# Managed by pre-commit installer"
        if !configContent.contains(marker) {
            configContent += "\n\n\(marker)\n"
        }
        
        // Add hooks by repo
        for (repo, hooks) in hooksByRepo {
            if let rev = hooks.first?.rev {
                configContent += """
                
                -   repo: \(repo)
                    rev: \(rev)
                    hooks:
                """
                
                for hook in hooks {
                    configContent += "\n      - id: \(hook.id)"
                }
            }
        }
        
        // Add local hooks
        if !localHooks.isEmpty {
            configContent += """
            
            -   repo: local
                hooks:
            """
            
            for hook in localHooks {
                configContent += """
                
                  - id: \(hook.id)
                    name: \(hook.name)
                    entry: \(hook.entry)
                    language: \(hook.language)
                    stages: [pre-commit]
                """
            }
        }
        
        try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        
        if verbose {
            print("✓ Updated config file with selected hooks".green)
        }
    }
    
    // Update config file with selected hook templates
    func updateConfigFileWithTemplates(selectedTemplates: [String]) throws {
    try updateConfigFileWithTemplatesFixed(selectedTemplates: selectedTemplates)
}
    
    // Install hooks via pre-commit
    func installHooks(types: [String] = ["pre-commit", "pre-push"]) throws {
        for hookType in types {
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
            process.arguments = ["pre-commit", "install", "-t", hookType]
            
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            
            do {
                try process.run()
                process.waitUntilExit()
                
                if process.terminationStatus != 0 {
                    let data = pipe.fileHandleForReading.readDataToEndOfFile()
                    let output = String(data: data, encoding: .utf8) ?? "Unknown error"
                    throw InstallerError.hookInstallationFailed(hookType, output)
                }
            } catch {
                throw InstallerError.hookInstallationFailed(hookType, error.localizedDescription)
            }
            
            if verbose {
                print("✓ Installed \(hookType) hook".green)
            }
        }
    }
}

// MARK: - Errors

enum InstallerError: Error, LocalizedError {
    case missingDependencies([String])
    case downloadFailed(String)
    case extractionFailed(String)
    case hookInstallationFailed(String, String)
    case generic(String)
    
    var errorDescription: String? {
        switch self {
        case .missingDependencies(let deps):
            return "Missing dependencies: \(deps.joined(separator: ", "))"
        case .downloadFailed(let reason):
            return "Failed to download repository: \(reason)"
        case .extractionFailed(let reason):
            return "Failed to extract repository: \(reason)"
        case .hookInstallationFailed(let hookType, let reason):
            return "Failed to install \(hookType) hook: \(reason)"
        case .generic(let message):
            return message
        }
    }
} 

import Foundation
import Rainbow

/// Installer service patch that properly handles YAML templates
extension InstallerService {
    
    /// Update config file with selected hook templates - fixed version
    func updateConfigFileWithTemplatesFixed(selectedTemplates: [String]) throws {
        let configPath = Config.configFile
        
        // Create or read existing config
        var configContent = ""
        if fileManager.fileExists(atPath: configPath) {
            configContent = try String(contentsOfFile: configPath, encoding: .utf8)
        } else {
            // Create default config if it doesn't exist
            configContent = """
            # See https://pre-commit.com/ for more information
            # See https://pre-commit.com/hooks.html for more hooks
            # This file is managed by the pre-commit-configs installer.
            # Default configurations (optional)
            default_stages: [pre-commit] # Sensible default
            default_install_hook_types: [pre-commit, pre-push, commit-msg]
            # default_language_version:
            #   python: python3.9
            repos:
              # Add hooks here using the installer or manually
            """
            try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        // Add managed section marker if not present
        let managedMarker = "# --- Managed by pre-commit-configs installer ---"
        if !configContent.contains(managedMarker) {
            // Look for repos: section and add marker after it
            if let _ = configContent.range(of: "repos:") {
                // Find the appropriate insertion point
                var lines = configContent.components(separatedBy: .newlines)
                let reposLineIndex = lines.firstIndex { $0.contains("repos:") } ?? 0
                
                // Insert marker after any comments following repos:
                var insertLineIndex = reposLineIndex + 1
                while insertLineIndex < lines.count && (lines[insertLineIndex].trimmingCharacters(in: .whitespacesAndNewlines).hasPrefix("#") || lines[insertLineIndex].trimmingCharacters(in: .whitespacesAndNewlines).isEmpty) {
                    insertLineIndex += 1
                }
                
                lines.insert("  \(managedMarker)", at: insertLineIndex)
                configContent = lines.joined(separator: "\n")
            } else {
                // No repos section found, add it with the marker
                configContent += """
                
                repos:
                  \(managedMarker)
                """
            }
            
            // Save the updated config with marker
            try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        // Process each template
        for templateDir in selectedTemplates {
            let hooksTemplatesPath = "hooks-templates" as NSString
            let templateDirPath = hooksTemplatesPath.appendingPathComponent(templateDir)
            let templatePath = (templateDirPath as NSString).appendingPathComponent("template.yaml")
            
            if fileManager.fileExists(atPath: templatePath) {
                let templateContent = try String(contentsOfFile: templatePath, encoding: .utf8)
                
                // Extract template entries
                let processedTemplate = processTemplate(templateContent)
                if !processedTemplate.isEmpty {
                    // Add template to config content
                    let lines = configContent.components(separatedBy: .newlines)
                    var newLines = [String]()
                    var insertedTemplate = false
                    
                    for line in lines {
                        newLines.append(line)
                        if line.contains(managedMarker) && !insertedTemplate {
                            // Add template lines after the marker with proper indentation
                            let templateLines = processedTemplate.components(separatedBy: .newlines)
                                .map { "  \($0)" } // Add proper indentation
                            newLines.append(contentsOf: templateLines)
                            insertedTemplate = true
                        }
                    }
                    
                    // If we couldn't find the marker, add at the end
                    if !insertedTemplate {
                        if !newLines.isEmpty {
                            newLines.append("")  // Add empty line for separation
                        }
                        let templateLines = processedTemplate.components(separatedBy: .newlines)
                            .map { "  \($0)" } // Add proper indentation
                        newLines.append(contentsOf: templateLines)
                    }
                    
                    configContent = newLines.joined(separator: "\n")
                    
                    if verbose {
                        print("✓ Added template from \(templateDir)".green)
                    }
                }
            } else if verbose {
                print("⚠️ Template file not found: \(templatePath)".yellow)
            }
        }
        
        // Write updated config
        try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        
        if verbose {
            print("✓ Updated config file with selected templates".green)
        }
    }
    
    /// Process a template file content for proper insertion into the config
    private func processTemplate(_ content: String) -> String {
        // Remove first comment line if it exists
        var lines = content.components(separatedBy: .newlines)
        
        // Clean up lines - remove any leading/trailing empty lines
        while !lines.isEmpty && lines.first!.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            lines.removeFirst()
        }
        while !lines.isEmpty && lines.last!.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            lines.removeLast()
        }
        
        // Skip first line if it's a comment (usually the template title)
        if !lines.isEmpty && lines.first!.trimmingCharacters(in: .whitespacesAndNewlines).hasPrefix("#") {
            lines.removeFirst()
        }
        
        // Process remaining lines to ensure proper YAML structure
        return lines.joined(separator: "\n")
    }
}


import Foundation
import Rainbow

/// Installer service patch that properly handles YAML templates
extension InstallerService {
    
    /// Update config file with selected hook templates - fixed version that includes the entire template
    func updateConfigFileWithTemplatesFixed(selectedTemplates: [String]) throws {
        let configPath = Config.configFile
        
        // Create or read existing config
        var configContent = ""
        if fileManager.fileExists(atPath: configPath) {
            configContent = try String(contentsOfFile: configPath, encoding: .utf8)
        } else {
            // Create default config if it doesn't exist
            configContent = """
            # See https://pre-commit.com/ for more information
            # See https://pre-commit.com/hooks.html for more hooks
            # This file is managed by the pre-commit-configs installer.
            # Default configurations (optional)
            default_stages: [pre-commit] # Sensible default
            default_install_hook_types: [pre-commit, pre-push, commit-msg]
            # default_language_version:
            #   python: python3.9
            repos:
              # Add hooks here using the installer or manually
            """
            try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        // Add managed section marker if not present
        let managedMarker = "# --- Managed by pre-commit-configs installer ---"
        if !configContent.contains(managedMarker) {
            // Look for repos: section and add marker after it
            if let _ = configContent.range(of: "repos:") {
                // Find the appropriate insertion point
                var lines = configContent.components(separatedBy: .newlines)
                let reposLineIndex = lines.firstIndex { $0.contains("repos:") } ?? 0
                
                // Insert marker after any comments following repos:
                var insertLineIndex = reposLineIndex + 1
                while insertLineIndex < lines.count && (lines[insertLineIndex].trimmingCharacters(in: .whitespacesAndNewlines).hasPrefix("#") || lines[insertLineIndex].trimmingCharacters(in: .whitespacesAndNewlines).isEmpty) {
                    insertLineIndex += 1
                }
                
                lines.insert("  \(managedMarker)", at: insertLineIndex)
                configContent = lines.joined(separator: "\n")
            } else {
                // No repos section found, add it with the marker
                configContent += """
                
                repos:
                  \(managedMarker)
                """
            }
            
            // Save the updated config with marker
            try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        // Process each template
        for templateDir in selectedTemplates {
            let hooksTemplatesPath = "hooks-templates" as NSString
            let templateDirPath = hooksTemplatesPath.appendingPathComponent(templateDir)
            let templatePath = (templateDirPath as NSString).appendingPathComponent("template.yaml")
            
            if fileManager.fileExists(atPath: templatePath) {
                let templateContent = try String(contentsOfFile: templatePath, encoding: .utf8)
                
                // Process the template content - PRESERVE EVERYTHING including comments
                if !templateContent.isEmpty {
                    // Add template to config content
                    let lines = configContent.components(separatedBy: .newlines)
                    var newLines = [String]()
                    var insertedTemplate = false
                    
                    for line in lines {
                        newLines.append(line)
                        if line.contains(managedMarker) && !insertedTemplate {
                            // Add template lines after the marker with proper indentation
                            // Remove the "- " prefix from the first line if it exists
                            // This is because we're handling the template content in its raw form
                            let templateLines = processFullTemplate(templateContent)
                                .map { "  \($0)" } // Add proper indentation
                            newLines.append(contentsOf: templateLines)
                            insertedTemplate = true
                        }
                    }
                    
                    // If we couldn't find the marker, add at the end
                    if !insertedTemplate {
                        if !newLines.isEmpty {
                            newLines.append("")  // Add empty line for separation
                        }
                        let templateLines = processFullTemplate(templateContent)
                            .map { "  \($0)" } // Add proper indentation
                        newLines.append(contentsOf: templateLines)
                    }
                    
                    configContent = newLines.joined(separator: "\n")
                    
                    if verbose {
                        print("✓ Added template from \(templateDir)".green)
                    }
                }
            } else if verbose {
                print("⚠️ Template file not found: \(templatePath)".yellow)
            }
        }
        
        // Write updated config
        try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        
        if verbose {
            print("✓ Updated config file with selected templates".green)
        }
    }
    
    /// Process the full template content for insertion into the config
    /// Preserves ALL content including comments
    private func processFullTemplate(_ content: String) -> [String] {
        // Split into lines
        var lines = content.components(separatedBy: .newlines)
        
        // Clean up lines - remove any leading/trailing empty lines only
        while !lines.isEmpty && lines.first!.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            lines.removeFirst()
        }
        while !lines.isEmpty && lines.last!.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            lines.removeLast()
        }
        
        // Process the template to ensure proper YAML structure if needed
        // For example, if it's a complete YAML document that needs restructuring
        
        // Check if first non-comment line starts with "- repo:"
        var foundFirstRepo = false
        for i in 0..<lines.count {
            let trimmed = lines[i].trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmed.hasPrefix("#") && !trimmed.isEmpty {
                if trimmed.hasPrefix("- repo:") || trimmed.hasPrefix("-") {
                    foundFirstRepo = true
                }
                break
            }
        }
        
        // If no repo entry found, we may need to restructure
        if !foundFirstRepo && !lines.isEmpty {
            // This is a simplified approach - in practice you might need more sophisticated parsing
            if verbose {
                print("Warning: Template does not appear to start with a repo entry. It may require manual adjustment.".yellow)
            }
        }
        
        return lines
    }
}
