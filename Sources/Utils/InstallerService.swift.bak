import Foundation
import Rainbow

// Service handling actual installation of hooks and scripts
class InstallerService {
    private let fileManager = FileManager.default
    private let tempDir: String
    private var verbose: Bool
    
    // Current state tracking
    var selectedHooks: Set<String> = []
    var selectedScripts: Set<String> = []
    var availableTemplates: [(String, String)] = []
    var hookTemplates: [HookTemplate] = []
    
    init(verbose: Bool = false) throws {
        self.verbose = verbose
        // Create a unique temporary directory for the installation process
        tempDir = (NSTemporaryDirectory() as NSString).appendingPathComponent(UUID().uuidString)
        try fileManager.createDirectory(atPath: tempDir, withIntermediateDirectories: true, attributes: nil)
        
        if verbose {
            print("ℹ️ Temporary directory created at \(tempDir)".blue)
        }
    }
    
    deinit {
        // Clean up temporary directory
        try? fileManager.removeItem(atPath: tempDir)
        if verbose {
            print("ℹ️ Temporary directory removed".blue)
        }
    }
    
    // MARK: - Verification and Setup
    
    // Verify all necessary dependencies are available
    func verifyDependencies() throws {
        let requiredCommands = ["git", "pre-commit", "tar", "curl"]
        var missingDeps: [String] = []
        
        if verbose {
            print("Verifying dependencies...".yellow)
        }
        
        for cmd in requiredCommands {
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/which")
            process.arguments = [cmd]
            
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            
            do {
                try process.run()
                process.waitUntilExit()
                if process.terminationStatus != 0 {
                    missingDeps.append(cmd)
                }
            } catch {
                missingDeps.append(cmd)
            }
        }
        
        if !missingDeps.isEmpty {
            throw InstallerError.missingDependencies(missingDeps)
        }
        
        if verbose {
            print("✓ All dependencies are available".green)
        }
    }
    
    // Download the repository containing hook templates
    func downloadRepository(progressHandler: ((Double, String) -> Void)? = nil) throws {
        let archiveURL = Config.archiveURL
        let destinationURL = URL(fileURLWithPath: tempDir).appendingPathComponent("repo.tar.gz")
        
        // Helper function to update progress
        func updateProgress(_ progress: Double, _ message: String) {
            progressHandler?(progress, message)
        }
        
        updateProgress(0.1, "Starting download...")
        
        // Download using URLSession
        let semaphore = DispatchSemaphore(value: 0)
        var downloadError: Error?
        
        let task = URLSession.shared.downloadTask(with: URL(string: archiveURL)!) { tempURL, response, error in
            if let error = error {
                downloadError = error
                semaphore.signal()
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse, 
                  (200...299).contains(httpResponse.statusCode) else {
                downloadError = InstallerError.downloadFailed("HTTP error")
                semaphore.signal()
                return
            }
            
            guard let tempURL = tempURL else {
                downloadError = InstallerError.downloadFailed("No download URL")
                semaphore.signal()
                return
            }
            
            do {
                try self.fileManager.moveItem(at: tempURL, to: destinationURL)
                updateProgress(0.5, "Download complete, extracting...")
                semaphore.signal()
            } catch {
                downloadError = error
                semaphore.signal()
            }
        }
        
        task.resume()
        semaphore.wait()
        
        if let downloadError = downloadError {
            throw InstallerError.downloadFailed(downloadError.localizedDescription)
        }
        
        // Extract tar.gz
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/tar")
        process.arguments = ["xzf", destinationURL.path, "-C", tempDir, "--strip-components=1"]
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            if process.terminationStatus != 0 {
                let errorData = pipe.fileHandleForReading.readDataToEndOfFile()
                let errorString = String(data: errorData, encoding: .utf8) ?? "Unknown error"
                throw InstallerError.extractionFailed(errorString)
            }
        } catch {
            throw InstallerError.extractionFailed(error.localizedDescription)
        }
        
        updateProgress(1.0, "Repository setup complete")
    }
    
    // MARK: - Hook and Script Management
    
    // Get available script templates
    func getAvailableTemplates() throws -> [(String, String)] {
        let scriptsDir = (tempDir as NSString).appendingPathComponent(Config.scriptsDir)
        
        guard fileManager.fileExists(atPath: scriptsDir) else {
            return []
        }
        
        let contents = try fileManager.contentsOfDirectory(atPath: scriptsDir)
        let templates = contents.filter { $0.hasSuffix(".sh") }.map { filename in
            (filename, getScriptDescription(filename: filename, inDirectory: scriptsDir))
        }
        
        self.availableTemplates = templates
        return templates
    }
    
    // Get hook templates from hooks-templates directory
    func getHookTemplates() throws -> [HookTemplate] {
        let templatesDir = "hooks-templates" // Path relative to the current directory
        
        guard fileManager.fileExists(atPath: templatesDir) else {
            if verbose {
                print("Hook templates directory not found: \(templatesDir)".yellow)
            }
            return []
        }
        
        // Get list of template directories
        let templateDirs = try fileManager.contentsOfDirectory(atPath: templatesDir)
        var templates: [HookTemplate] = []
        
        for dir in templateDirs {
            let dirPath = (templatesDir as NSString).appendingPathComponent(dir)
            
            // Skip non-directories
            var isDir: ObjCBool = false
            if !fileManager.fileExists(atPath: dirPath, isDirectory: &isDir) || !isDir.boolValue {
                continue
            }
            
            // Read README.md for description
            let readmePath = (dirPath as NSString).appendingPathComponent("README.md")
            var description = "No description available"
            if fileManager.fileExists(atPath: readmePath) {
                if let readmeContent = try? String(contentsOfFile: readmePath, encoding: .utf8) {
                    description = extractSummaryFromReadme(readmeContent)
                }
            }
            
            // Read template.yaml for configuration
            let templatePath = (dirPath as NSString).appendingPathComponent("template.yaml")
            var configContent = "No configuration available"
            if fileManager.fileExists(atPath: templatePath) {
                if let templateContent = try? String(contentsOfFile: templatePath, encoding: .utf8) {
                    configContent = templateContent
                }
            }
            
            // Create template object
            let template = HookTemplate(
                name: formatTemplateName(dir),
                directory: dir,
                description: description,
                configuration: configContent,
                isSelected: selectedHooks.contains(dir)
            )
            
            templates.append(template)
        }
        
        // Sort templates by name
        templates.sort { $0.name < $1.name }
        
        // Store templates
        self.hookTemplates = templates
        return templates
    }
    
    // Helper to format template name from directory name
    private func formatTemplateName(_ dirName: String) -> String {
        // Convert kebab-case to title case (e.g. "accessibility-check" -> "Accessibility Check")
        return dirName.split(separator: "-")
            .map { $0.prefix(1).uppercased() + $0.dropFirst().lowercased() }
            .joined(separator: " ")
    }
    
    // Helper to extract a brief summary from README.md content
    private func extractSummaryFromReadme(_ content: String) -> String {
        let lines = content.components(separatedBy: .newlines)
        
        // Find the first paragraph after skipping the title
        var seenTitle = false
        var paragraphLines: [String] = []
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip empty lines
            if trimmedLine.isEmpty {
                continue
            }
            
            // Handle Markdown title lines
            if trimmedLine.hasPrefix("#") {
                seenTitle = true
                continue
            }
            
            // If we've seen the title, collect the paragraph lines
            if seenTitle && !trimmedLine.isEmpty {
                paragraphLines.append(trimmedLine)
                
                // If we hit another empty line, we've got our paragraph
                if paragraphLines.count >= 4 {
                    break
                }
            }
        }
        
        // Return the first paragraph, or a default if none found
        if !paragraphLines.isEmpty {
            return paragraphLines.joined(separator: " ")
        }
        
        // Fallback: return the first non-empty, non-title line
        return lines.first { 
            let trimmed = $0.trimmingCharacters(in: .whitespacesAndNewlines)
            return !trimmed.isEmpty && !trimmed.hasPrefix("#")
        } ?? "No description available"
    }
    
    // Helper to get description of a script template
    private func getScriptDescription(filename: String, inDirectory: String) -> String {
        let path = (inDirectory as NSString).appendingPathComponent(filename)
        guard let contents = try? String(contentsOfFile: path, encoding: .utf8) else {
            return "No description available"
        }
        
        // Try to extract description from script's comment
        let lines = contents.components(separatedBy: .newlines)
        if let descLine = lines.first(where: { 
            let trimmed = $0.trimmingCharacters(in: .whitespaces)
            return trimmed.hasPrefix("#") && !trimmed.hasPrefix("#!")
        }) {
            return descLine.trimmingCharacters(in: CharacterSet(charactersIn: "# "))
        }
        
        return "No description found"
    }
    
    // MARK: - Installation
    
    // Setup selected scripts
    func setupScripts(_ scripts: [String]) throws {
        let sourceDir = (tempDir as NSString).appendingPathComponent(Config.scriptsDir)
        let destDir = Config.scriptsDir
        
        // Create scripts directory if it doesn't exist
        if !fileManager.fileExists(atPath: destDir) {
            try fileManager.createDirectory(atPath: destDir, withIntermediateDirectories: true, attributes: nil)
        }
        
        for script in scripts {
            let sourcePath = (sourceDir as NSString).appendingPathComponent(script)
            let destPath = (destDir as NSString).appendingPathComponent(script)
            
            if fileManager.fileExists(atPath: destPath) {
                try fileManager.removeItem(atPath: destPath)
            }
            
            try fileManager.copyItem(atPath: sourcePath, toPath: destPath)
            
            // Make script executable
            try fileManager.setAttributes([.posixPermissions: 0o755], ofItemAtPath: destPath)
            
            if verbose {
                print("✓ Installed script: \(script)".green)
            }
        }
    }
    
    // Update config file with selected hooks
    func updateConfigFile(hookIds: Set<String>, availableHooks: [HookGroup]) throws {
        let configPath = Config.configFile
        
        // Create config file if it doesn't exist
        if !fileManager.fileExists(atPath: configPath) {
            let defaultConfig = """
            # Default pre-commit config generated by pre-commit installer
            repos:
            """
            try defaultConfig.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        var configContent = try String(contentsOfFile: configPath, encoding: .utf8)
        
        // Group selected hooks by repo
        var hooksByRepo: [String: [(id: String, rev: String)]] = [:]
        var localHooks: [(id: String, name: String, entry: String, language: String)] = []
        
        for hookId in hookIds {
            let allHooks = availableHooks.flatMap { $0.hooks }
            if let hook = allHooks.first(where: { $0.id == hookId }) {
                if hook.repo == "local" {
                    localHooks.append((
                        id: hook.id,
                        name: hook.description,
                        entry: "\(Config.scriptsDir)/\(hook.id).sh",
                        language: "script"
                    ))
                } else {
                    if hooksByRepo[hook.repo] == nil {
                        hooksByRepo[hook.repo] = []
                    }
                    hooksByRepo[hook.repo]!.append((id: hook.id, rev: hook.rev))
                }
            }
        }
        
        // Add marker for managed section
        let marker = "# Managed by pre-commit installer"
        if !configContent.contains(marker) {
            configContent += "\n\n\(marker)\n"
        }
        
        // Add hooks by repo
        for (repo, hooks) in hooksByRepo {
            if let rev = hooks.first?.rev {
                configContent += """
                
                -   repo: \(repo)
                    rev: \(rev)
                    hooks:
                """
                
                for hook in hooks {
                    configContent += "\n      - id: \(hook.id)"
                }
            }
        }
        
        // Add local hooks
        if !localHooks.isEmpty {
            configContent += """
            
            -   repo: local
                hooks:
            """
            
            for hook in localHooks {
                configContent += """
                
                  - id: \(hook.id)
                    name: \(hook.name)
                    entry: \(hook.entry)
                    language: \(hook.language)
                    stages: [pre-commit]
                """
            }
        }
        
        try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        
        if verbose {
            print("✓ Updated config file with selected hooks".green)
        }
    }
    
    // Update config file with selected hook templates
    func updateConfigFileWithTemplates(selectedTemplates: [String]) throws {
        let configPath = Config.configFile
        
        // Create config file if it doesn't exist
        if !fileManager.fileExists(atPath: configPath) {
            let defaultConfig = """
            # Default pre-commit config generated by pre-commit installer
            repos:
            """
            try defaultConfig.write(toFile: configPath, atomically: true, encoding: .utf8)
        }
        
        var configContent = try String(contentsOfFile: configPath, encoding: .utf8)
        
        // Add marker for managed section if it doesn't exist
        let marker = "# Managed by pre-commit installer"
        if !configContent.contains(marker) {
            configContent += "\n\n\(marker)\n"
        }
        
        // For each selected template, extract its configuration
        for templateDir in selectedTemplates {
            let hooksTemplatesPath = "hooks-templates" as NSString
            let templateDirPath = hooksTemplatesPath.appendingPathComponent(templateDir)
            let templatePath = (templateDirPath as NSString).appendingPathComponent("template.yaml")
            
            if fileManager.fileExists(atPath: templatePath) {
                if let templateContent = try? String(contentsOfFile: templatePath, encoding: .utf8) {
                    // Check if the template content is not empty
                    let trimmedContent = templateContent.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !trimmedContent.isEmpty {
                        // Add a newline before the template content for proper separation
                        configContent += "\n\n"
                        
                        // Add the entire template content
                        configContent += trimmedContent
                    }
                }
            } else if verbose {
                print("⚠️ Template file not found: \(templatePath)".yellow)
            }
        }
        
        try configContent.write(toFile: configPath, atomically: true, encoding: .utf8)
        
        if verbose {
            print("✓ Updated config file with selected templates".green)
        }
    }
    
    // Install hooks via pre-commit
    func installHooks(types: [String] = ["pre-commit", "pre-push"]) throws {
        for hookType in types {
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
            process.arguments = ["pre-commit", "install", "-t", hookType]
            
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            
            do {
                try process.run()
                process.waitUntilExit()
                
                if process.terminationStatus != 0 {
                    let data = pipe.fileHandleForReading.readDataToEndOfFile()
                    let output = String(data: data, encoding: .utf8) ?? "Unknown error"
                    throw InstallerError.hookInstallationFailed(hookType, output)
                }
            } catch {
                throw InstallerError.hookInstallationFailed(hookType, error.localizedDescription)
            }
            
            if verbose {
                print("✓ Installed \(hookType) hook".green)
            }
        }
    }
}

// MARK: - Errors

enum InstallerError: Error, LocalizedError {
    case missingDependencies([String])
    case downloadFailed(String)
    case extractionFailed(String)
    case hookInstallationFailed(String, String)
    case generic(String)
    
    var errorDescription: String? {
        switch self {
        case .missingDependencies(let deps):
            return "Missing dependencies: \(deps.joined(separator: ", "))"
        case .downloadFailed(let reason):
            return "Failed to download repository: \(reason)"
        case .extractionFailed(let reason):
            return "Failed to extract repository: \(reason)"
        case .hookInstallationFailed(let hookType, let reason):
            return "Failed to install \(hookType) hook: \(reason)"
        case .generic(let message):
            return message
        }
    }
} 